---
title: Docker 笔记
catalog: true
comments: true
date: 2022-03-28 20:00:00
subtitle: 学习 Docker 手册.
header-img: /img/header_img/home-bg-1-dark.jpg
tags:
    - Linux
    - Docker
categories:
    - 技术
---

# Docker 学习笔记

## 为什么要使用 Docker

- 更高效的利用系统资源
- 更快速的启动时间
- 一致的运行环境
- 持续交付和部署
- 更轻松的迁移
- 更轻松的维护和拓展

## 基本概念

- 镜像（Image）

    操作系统分为 **内核** 和 **用户空间**。对于 `Linux` 而言，内核启动后，会挂载 `root` 文件系统为其提供用户空间支持。而 **Docker 镜像**（`Image`），就相当于是一个 `root` 文件系统。**Docker 镜像** 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 **不包含** 任何动态数据，其内容在构建之后也不会被改变。

    在 Docker 设计时，就充分利用 [Union FS (opens new window)](https://en.wikipedia.org/wiki/Union_mount)的技术，将其设计为分层存储的架构。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。

    从 Docker 镜像仓库获取镜像的命令是 `docker pull`。其命令格式为：

    ```sh
    $ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
    ```

    运行 Docker 镜像。其命令格式为：

    ```sh
    $ docker run -it --rm ubuntu:18.04 bash
    ```

    列出已经下载下来的镜像，可以使用 docker image ls 命令

    ```sh
    $ docker image ls
    ```

    通过 `docker system df` 命令来便捷的查看镜像、容器、数据卷所占用的空间

    ```sh
    $ docker system df
    ```

    虚悬镜像问题，由于 docker pull 和 docker build 等操作导致 image 同版本号取代原来的镜像导致。

    显示虚悬镜像

    ```sh
    $ docker image ls -f dangling=true
    # 删除虚悬镜像
    $ docker image prune
    ```

    列出特定的镜像

    ```sh
    $ docker image ls ubuntu
    $ docker image ls -f since=mongo:3.2
    # -f 代表 -filter 的简称。
    ```

    删除本地的镜像，可以使用 `docker image rm` 命令，其格式为：

    ```sh
    $ docker image rm [选项] <镜像1> [<镜像2> ...]
    # <镜像> 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要
    ```

     Docker 提供了一个 `docker commit` 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。

    ```sh
    $ docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]
    ```

    通过 Dockerfile 构建镜像，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。（Docker 还存在一个特殊的镜像，名为 `scratch`，空白镜像） 镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。

    `docker build` 命令进行镜像构建。

    ```sh
    $ docker build [选项] <上下文路径/URL/->
    # 在 Dockfile 目录下执行这个命令， 上下文路径中的文件都会上传到 Daemon 中
    ```

    保存镜像

    ```sh
    $ docker save alpine -o filename
    # docker save alpine | gzip > alpine-latest.tar.gz
    ```

    加载镜像

    ```sh
    $ docker load -i alpine-latest.tar.gz
    ```

    

- 容器（Container）

    容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 [命名空间 (opens new window)](https://en.wikipedia.org/wiki/Linux_namespaces)。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。

    每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。

- 仓库（Repository）

    一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。

## Dockerfile 简介

- COPY 复制文件

  格式

  ```sh
  COPY [--chown=<user>:<group>] <源路径>... <目标路径>
  COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]
  # 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置
  # <目标路径> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。
  # 使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。
  # 可以使用通配符
  ```

- ADD 更高级的复制文件

  ```sh
  ADD [--chown=<user>:<group>] <源路径>... <目标路径>
  ADD [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]
  # add 可以说是 copy 命令的增强版，源路径可以为 URL 或 TAR 压缩文件，ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。同时，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。
  ```

  

